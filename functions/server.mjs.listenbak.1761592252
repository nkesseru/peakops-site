import { getDb } from './lib/admin.mjs';
getDb(); // initialize Firebase Admin singleton via ADC

/**
 * PeakOps prefile server (v1)
 * - JSON health, structured errors, graceful shutdown
 * - Versioned routes (/v1/...)
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import express from 'express';
import crypto from 'crypto';
import cors from 'cors';
import helmet from 'helmet';
import { getRulesMeta } from './controllers/meta.mjs';

import { handleOE417 } from './controllers/oe417.mjs';
import v1FixedRouter from './routes/v1_fixed.mjs';
import v1Router from './routes/v1.mjs';
import { loadRulePack, validatePayload } from '../src/rules/loader.mjs'; // still used for DIRS demo
import { exportSubmissionJSON, exportSubmissionPDF } from './controllers/export.mjs';

// ---------- Env & paths ----------
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const NODE_ENV = process.env.NODE_ENV || 'development';
const PORT = process.env.PORT || 8081;
const PROJECT_ID = process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT || process.env.FIREBASE_CONFIG?.projectId


// ---------- Express app ----------
const app = express();

// Trust reverse proxies if deployed behind one
app.set('trust proxy', 1);

// Security baseline (tune CSP later when UI attaches)
app.use(helmet({
  contentSecurityPolicy: false,
}));

// CORS: open in dev, tighten in prod
if (NODE_ENV !== 'production') {
  app.use(cors());
}

// Parse JSON with sane limits
app.use(express.json({ limit: '1mb', strict: true }));

// Request ID + timing
app.use((req, res, next) => {
  const rid = req.headers['x-request-id'] || crypto.randomUUID();
  res.locals.rid = rid;
  res.setHeader('x-request-id', rid);
  const start = Date.now();
  res.on('finish', () => {
    const ms = Date.now() - start;
    const line = JSON.stringify({
      ts: new Date().toISOString(),
      rid, method: req.method, path: req.originalUrl,
      status: res.statusCode, ms
    });
    console.log(line);
  });
  next();
});

// ---------- Health ----------
app.get('/health', async (_req, res) => {
  // Basic Firestore ping: list one doc from rules_registry (safe/no-throw)
  let registryOk = false;
  try {
    const snap = await db.collection('rules_registry').limit(1).get();
    registryOk = !snap.empty;
  } catch { registryOk = false; }

  res.json({
    ok: true,
    env: NODE_ENV,
    projectId: PROJECT_ID || null,
    uptimeSec: Math.round(process.uptime()),
    registryReady: registryOk,
    now: new Date().toISOString()
  });
});

// ---------- API v1 ----------
const api = express.Router();
// DOE OE-417 prefile (controller)
api.post('/prefile/oe417', handleOE417);

// Rules meta endpoint (returns active rule pack info)
api.get('/meta/rules/:regulator', getRulesMeta);
api.get('/export/submission/:id.json', exportSubmissionJSON);
api.get('/export/submission/:id.pdf',  exportSubmissionPDF);

// FCC DIRS prefile (inline demo using shared loader/validator)
api.post('/prefile/dirs', async (req, res, next) => {
  try {
    const { orgId, payload, extras } = req.body || {};
    const pack = await loadRulePack('FCC_DIRS', new Date(), orgId);
    const pre = validatePayload(pack, payload || {}, extras || {});
    if (!pre.passed) return res.status(422).json({ ok: false, issues: pre });

    const doc = await db.collection('submissions').add({
      regulator: 'FCC_DIRS',
      payload, preflight: pre,
      rule_pack: {
        regulator: 'FCC_DIRS',
        version_id: pack.version_id,
        pack_hash: pack.pack_hash || null,
        cfr_refs: pack.cfr_refs || [],
        codelists: pack.codelist_refs || []
      },
      created_at: new Date().toISOString()
    });
    res.json({ ok: true, id: doc.id });
  } catch (e) { next(e); }
});

app.use('/v1', v1FixedRouter);

// Fallback 404 (JSON only)
app.use((req, res) => {
  res.status(404).json({ ok: false, error: 'not_found', path: req.originalUrl });
});

// Error handler (never leak stack in prod)
app.use((err, req, res, _next) => {
  const rid = res.locals.rid;
  const status = err.status || 500;
  const payload = {
    ok: false,
    error: err.code || 'internal',
    message: NODE_ENV === 'production' ? 'Internal error' : String(err.message || err),
    rid
  };
  console.error('[error]', { rid, status, err: String(err) });
  res.status(status).json(payload);
});

// ---------- Start ----------
const server = app.listen(PORT, () => {
  console.log(`prefile server on :${PORT} env=${NODE_ENV} project=${PROJECT_ID || 'unknown'}`);
});

// Graceful shutdown
for (const sig of ['SIGINT', 'SIGTERM']) {
  process.on(sig, () => {
    console.log(`[shutdown] ${sig} received`);
    server.close(() => {
      console.log('[shutdown] http server closed');
      process.exit(0);
    });
    // Force exit after 5s if hanging
    setTimeout(() => process.exit(1), 5000).unref();
  });
}

// ---------- Health endpoint ----------
app.get('/health', (req, res) => {
  res.json({
    ok: true,
    env: process.env.NODE_ENV || 'development',
    project: process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT || 'peakops-pilot',
    ts: new Date().toISOString()
  });
});

// ---------- Routers ----------
app.use('/v1_fixed', v1FixedRouter);
app.use('/v1', v1Router);

// ---------- Start server ----------
app.listen(PORT, () => {
  console.log(`prefile server on :${PORT} env=${NODE_ENV} project=${PROJECT_ID}`);
});

// graceful shutdown
process.on('SIGINT', () => {
  console.log('Shutting down server...');
  process.exit(0);
});
